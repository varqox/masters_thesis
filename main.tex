%
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[licencjacka,en]{pracamgr}

% Code listings
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
% Diagrams
\usepackage{tikz}
\usetikzlibrary{calc,positioning,arrows.meta,shapes,fit}

\usepackage{pgfplots}
\usepgfplotslibrary{groupplots}
\pgfplotsset{width=10cm, compat=1.9}
\usepackage{float}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{basicstyle = \ttfamily, style=mystyle, frame=single, numbers=none, columns=fullflexible, upquote=true}
% End code listings

% Hrefs
\usepackage[colorlinks]{hyperref}
\usepackage{caption} % makes clicking figure \ref navigate to the top of the figure instead of the caption
% End hrefs

\usepackage{biblatex}
\usepackage{csquotes}

\addbibresource{references.bib}

% Dane magistranta:
\autor{Krzysztof Małysa}{394442}

\title{Multi-process sandbox for unprivileged users on Linux}
\titlepl{Sandbox wielu procesów dla nieuprzywilejowanych użytkowników systemu Linux}

%\tytulang{An implementation of a difference blabalizer based on the theory of $\sigma$ -- $\rho$ phetors}

%kierunek:
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{Computer Science}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{dr Janina Mincer-Daszkiewicz}

% miesiąc i~rok:
\date{September 2022}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{
%11.0 Matematyka, Informatyka:\\
%11.1 Matematyka\\
%11.2 Statystyka\\
11.3 Informatics, Computer Science\\
%11.4 Sztuczna inteligencja\\
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{Security and privacy -- Systems security -- Operating systems security}

% Słowa kluczowe:
\keywords{sandboxing, security, container, Linux, capabilities, cgroups, user namespace, PID namespace, mount namespace, secure execution, arbitrary code execution, rlimit, seccomp, ptrace}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
% \newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\renewcommand\textfraction{0}

\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
We introduce a new sandbox for unprivileged Linux users that requires no kernel modifications. It takes advantage of several Linux mechanisms used elsewhere --- cgroups, namespaces, ptrace and seccomp among others. The sandbox was optimized to run dozens of untrusted programs in a sequence with minimal overhead while preserving the safety. It is capable of running both multi-threaded and multi-process programs. It is able to record the peek memory usage and CPU execution time of multithreaded program, alas these statistics are unavailable for multi-process programs.
We describe the encountered limitation and challenges around enforcing safety and collecting statistics. Further, we examine its ability to run complex multi-process programs like C++ compiler and the overhead when running a series of short-running programs.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter{Introduction}

The objective of this project is to create safe and efficient sandbox to execute short running untrusted programs, as well as complex programs e.g. compiler of a C++ program. All done with robust isolation and minimal overhead (the order of milliseconds).

The primary use case is an online judge whose job is to
\begin{itemize}
    \item compile user-provided source code
    \item run it several times (even hundreds) with different inputs
    \item verify the output correctness usually by running another program
\end{itemize}
All of these tasks require at least ensuring that
\begin{itemize}
    \item real time is limited
    \item CPU time is limited
    \item memory is limited
    \item disk space is limited
    \item file access is isolated
    \item network is isolated or disabled
\end{itemize}
Also statistics about the executed program are required
\begin{itemize}
    \item real time used
    \item CPU time used
    \item peek memory usage
\end{itemize}
All of that is to be done as an unprivileged user.

Such combination (especially minimal overhead and recording the peek memory usage) is very uncommon e.g. Firejail (TODO: reference) does not provide memory statistics. LXC (TODO: reference) and Docker require privileges to create a container. Thereby, the listed constraints require a new solution.

In the chapter \ref{chapter:linux_mechanism}, we describe the Linux kernel mechanisms used in the project and . Design of the sandbox is described in chapter \ref{chapter:design} along with security considerations and decisions made in the process along with the encountered limitations such as inability to record the peak memory usage and total CPU time when more that one process is running. The chapter \ref{chapter:evaluation} contains performance measurements of the sandbox and evaluation of ability to run complex programs like C++ compiler or \LaTeX engine.

\chapter{Useful Linux kernel mechanisms} \label{chapter:linux_mechanism}

TODO

\section{User namespaces}
TODO

\section{PID namespaces}
TODO

\section{Mount namespaces}

Mount namespaces allow for isolation of mounts i.e. process in one namespace can modify its mount list without affecting others' mount lists, or affecting or being affected by others in a controlled manner thanks to the Shared Subtrees feature of the Linux kernel \cite{shared_subtree}.

\subsection{Terminology}

The most typical use case of \texttt{mount} is mounting a filesystem at some location in a filesystem e.g. mounting home directory: \texttt{mount /dev/sda2 /home/user} or mounting the temporary filesystem at \texttt{/tmp}: \texttt{mount -t tmpfs tmpfs /tmp}. Filesystem can be mounted at multiple locations e.g. \texttt{mount /dev/sda2 /a \&\& mount /dev/sda2 /b}. Such location is called a \textbf{mount point}. As it will be explained later, a single \textbf{mount} has a single mount points. But a single \texttt{mount} operation may result in more than one mounts.

List of all mounts of a mount namespace of a process with PID \texttt{[pid]} can be examined via file \texttt{/proc/[pid]/mountinfo}.

\paragraph{Mount} is a result of a \texttt{mount} operation and is a filesystem that is accessible at a specified location called a \texttt{mount point}.

\paragraph{Mount point} is a location where mount in attached.

\paragraph{Propagation type} affects how mounts that happen directly under that mount are propagated to other members of the \texttt{peer group} and its slave peer groups. It can be one of:
\begin{itemize}
    \item \texttt{shared} Its peer group can have any size and mount events propagate to other members and from other members of the peer group.
    \item \texttt{slave} Its peer group has only one member --- itself and has a master peer group. Mount events propagate from the master peer group, but not to the master peer group.
    \item \texttt{slave \& shared} Its peer group can have any size and has a master peer group. Mount events propagate between members of the slave \& shared peer group but not to the master peer group. Mount events from the master peer group propagate to all members of the slave \& shared peer group.
    \item \texttt{private} Its peer group has only one member --- itself. No mount events propagate from this peer group to another and vice versa.
    \item \texttt{unbindable} Same as \texttt{private}, but bind mounts with source inside this mount are forbidden.
\end{itemize}

\paragraph{Peer group} is a group of mounts that propagate mounts between one another.

These notions are best illustrated in an example. First we mount \texttt{tmpfs} at \texttt{/mnt} and make its propagation type \texttt{shared}, later we examine the mount list after this operation.
\begin{lstlisting}
# mount -t tmpfs tmpfs /mnt --make-shared
# cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'
619 27 0:69 / /mnt rw,relatime shared:274
\end{lstlisting}
Now we create a \texttt{/tmp/mnt} and bind mount there the \texttt{/mnt}.
\begin{lstlisting}
# mkdir /tmp/mnt
# mount --bind /mnt /tmp/mnt
# cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'
619 27 0:69 / /mnt rw,relatime shared:274
773 39 0:69 / /tmp/mnt rw,relatime shared:274
\end{lstlisting}
We see that both of these mounts have \texttt{shared:274} --- it means that the mount has propagation type \texttt{shared} and \texttt{274} is the id of the peer group. So both mounts are in the same peer group.
Apart from the fact that these mount points have the same filesystem underneath (because of the bind mount):
\begin{lstlisting}
# ls /mnt
# ls /tmp/mnt
# touch /mnt/a
# touch /tmp/mnt/b
# ls /mnt
a  b
# ls /tmp/mnt
a  b
\end{lstlisting}
They also propagate mount events between them (because of the propagation type \texttt{shared}):
\begin{lstlisting}
# mkdir /mnt/c
# mount -t tmpfs tmpfs /mnt/c
# cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'
619 27 0:69 / /mnt rw,relatime shared:274
773 39 0:69 / /tmp/mnt rw,relatime shared:274
794 619 0:71 / /mnt/c rw,relatime shared:415
795 773 0:71 / /tmp/mnt/c rw,relatime shared:415
\end{lstlisting}
We can see that mount at \texttt{/mnt/c} propagated to \texttt{/tmp/mnt} as \texttt{/tmp/mnt/c}.

E.g. with a private propagation type mounts are not propagated.
\begin{lstlisting}
# mount -t tmpfs tmpfs /mnt --make-private
# cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'
619 27 0:69 / /mnt rw,relatime
\end{lstlisting}
\begin{lstlisting}
# mkdir /tmp/mnt
# mount --bind /mnt /tmp/mnt
# cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'
619 27 0:69 / /mnt rw,relatime
773 39 0:69 / /tmp/mnt rw,relatime shared:274
\end{lstlisting}
\begin{lstlisting}
# ls /mnt
# ls /tmp/mnt
# touch /mnt/a
# touch /tmp/mnt/b
# ls /mnt
a  b
# ls /tmp/mnt
a  b
\end{lstlisting}
\begin{lstlisting}
# mkdir /mnt/c
# mount -t tmpfs tmpfs /mnt/c
# cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'
619 27 0:69 / /mnt rw,relatime
773 39 0:69 / /tmp/mnt rw,relatime shared:274
794 619 0:71 / /mnt/c rw,relatime
\end{lstlisting}

\texttt{slave} propagation type allows for propagation only in one direction, from the master peer group to the slave peer group.

More details about all propagation types and the semantics of all \texttt{mount} operations are be described in the following subsections.

\subsection{Semantics}
TODO

\section{cgroups}
TODO

\section{cgroup namespaces}
TODO

\section{Capabilities}
TODO

\section{ptrace}
TODO

\section{seccomp} \label{section:seccomp}
TODO

\chapter{Sandbox design} \label{chapter:design}

\section{Assumptions}

The primary assumption is that the validation and enforcement during the interaction of an untrusted program and the Linux kernel is enough to prevent the program from doing anything unwanted. Thus satinization of all syscalls either directly (using \texttt{ptrace} and \texttt{seccomp}) or indirectly (using capabilities, cgroups, namespaces e.g. mount namespaces, and limits e.g. \texttt{prlimit()}). Thereby executing the program while no syscalls are invoked is considered safe. In general however, this is not true, e.g. \texttt{io\_uring} can be used to ''call syscalls'' without actually executing any syscall \cite{lwn_io_uring}. Another example is writing to memory mapped file just by writing to the memory region where the file is mapped to. Such dangerous situations need to be prevented by properly forbidding or sanitizing syscalls that are necessary for such situations to happen i.e. preventing \texttt{io\_uring} syscalls and forbidding mapping of the unwanted files.

\section{Sandbox server}

Sandbox is spawned as a separate process and this process executes sandboxing requests e.g. execute program A with configuration B. Communication between the caller and the sandbox server process uses UNIX domain socket. Errors regarding handling a specific request are reported through the UNIX socket as a response to the sandbox request. A separate anonymous file (created using \texttt{memfd\_create()}) is used for reporting fatal errors of the sandbox server process - it fills the file with an error description and dies afterwards. Such separation allows for a simpler protocol to be used for communicating through the UNIX socket e.g. reporting errors about writing to the socket are reported using the anonymous file instead of the socket itself. Figure \ref{fig:caller_to_sandbox_server_communication} illustrates the design.

\begin{figure}[h]
\tikzset{>=latex} % set latex arrow tip
\centering
\begin{tikzpicture}[align=center]
    \node [draw] (errors) {anonymous file\\for errors};
    % \node [draw, above left=1.5cm of errors, minimum height=1.9777087639995352cm, minimum width=3.2cm] (caller_thread) {caller thread};
    \node [draw, above left=1.5cm of errors, minimum height=1.9777087639995352cm, minimum width=3.2cm] (caller) {caller};
    \node [draw, above right=1.5cm of errors, minimum height=1.9777087639995352cm, minimum width=3.2cm] (server) {sandbox server\\process};
    \node [above left=2cm of caller] (phantom) {};
    % \node [draw, fit=(caller_thread) (phantom), text depth=3cm, text height=0.7cm] (caller_process) {caller process}; TODO: sandbox server waits for the caller thread / process to die or the socket to be closed?
    \draw [<->] (caller) -- node[above] {UNIX socket} (server);
    \draw[->] (caller) |- node[below] {\texttt{server\_error\_fd}} (errors);
    \draw[->] (server) |- node[below] {\texttt{stderr}} (errors);
\end{tikzpicture}
\caption{Caller requests and receives results of executing untrusted programs through UNIX socket. Sandbox server process dies on error leaving the error message for the caller in an anonymous file.}
\label{fig:caller_to_sandbox_server_communication}
\end{figure}

Sandbox needs to execute an untrusted executable. To do this it needs to \texttt{fork()} a child process and call \texttt{execve()} in the child process. Our use case involves executing short-running programs frequently. \texttt{fork()} syscall may take a long time \cite{redis-latency-generated-by-fork} - the bigger RSS (resident set size - RAM pages that are actually in use) the longer time \texttt{fork()} needs. To reduce \texttt{fork()} latency, the caller spawns sandbox server process that executes a separate executable -- containing only the sandbox, therefore reducing the RSS to the minimum and speeding up \texttt{fork()}. Additional benefits of this approach are setting up all common work before running executing the untrusted executable once i.e. when the sandbox server starts e.g. closing stray file descriptors not marked with \texttt{O\_CLOEXEC} flag and setting up cgroups. The only overhead is passing data and file descriptors through the UNIX socket -- from caller to the sandbox server process and back.

\section{Limiting the number of processes and threads}
TODO: cgroup

\section{Isolating filesystem}
TODO

\section{Limiting memory}
TODO: prlimit + cgroup

\section{Limiting execution time}
TODO

\section{Collecting statistics}

\subsection{Execution real time}
TODO

\subsection{Execution CPU time}
TODO

\subsection{Peek memory usage}
TODO

% \section{}

\chapter{Evaluation} \label{chapter:evaluation}

\printbibliography

\end{document}
